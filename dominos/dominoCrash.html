<!doctype html>
<html lang="en">
	<head>
		<title>Domino Crash v1.0</title>
		<a href="https://www.freepik.com/free-photos-vectors/background">Background photo created by tirachard - www.freepik.com</a>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel=stylesheet href="../libs/base.css"/>
	</head>
	<body>
		<div id="infoButton"></div>
		<div id="infoBox" title="Demo Information" style="text-align: center; margin-bottom: 10px">
			<ul>
				<li>A - add domino</li>
				<li>D - remove domino</li>
				<li>X - delete selected domino</li>
				<li>left arrow - crash left</li>
				<li>right arrow- crash right</li>
				<li>R - rotate domino</li>
				<li>M - full screen</li>
				<li>escape - exit full screen</li>
				<li>0 - restart</li>
				<li>mouse left - set domino</li>
				<li>mouse right - select domino</li>
				<p style="font-weight: 10000 ">In order to select domino and do anything with selected domino - you must first exit seeding mode by pressing letter 'D'</p>
			</ul>
		</div>
		<div id="color" style=""></div>
		<div id="dominoSite" style="position: absolute; left:0px; top:0px"></div>

		<link rel=stylesheet href="../libs/jquery-ui.css"/>		
		<link rel=stylesheet href="../libs/info.css"/>		

		
		<script src="../libs/three1.js"></script>		
		<script src="../libs/Detector.js"></script>
		<script src="../libs/OrbitControls.js"></script>
		<script src="../libs/FirstPersonControls.js"></script>
		<script type="text/javascript" src="../libs/dat.gui.js"></script>
		<script type="text/javascript" src="../physi.js"></script>
		<script type="text/javascript" src="../libs/stats.js"></script>
		<script src="../libs/THREEx.KeyboardState.js"></script>
		<script src="../libs/THREEx.FullScreen.js"></script>
		<script src="../libs/THREEx.WindowResize.js"></script>
		<script src="../libs/jquery-1.9.1.js"></script>
		<script src="../libs/jquery-ui.js"></script>
		<script type="text/javascript" src="../libs/Projector.js"></script>
		<script src="../libs/info.js"></script>
		<script>

			'use strict';

			Physijs.scripts.worker = '../libs/physijs_worker.js';
			Physijs.scripts.ammo = '../libs/ammo.js';

			var renderer, scene, container, controls, light, camera;
			var keyboard = new THREEx.KeyboardState();
			var dominos = [];
			var touched = false;
			var addDom = false;
			var crash = 0;
			var selColor = 0x77dd77;
			var crashDomino = 0;
			var counter = 0;
			var selected = false;
			var pickedObject;
			var selMaterial = 'domino2';

			init();
			animate();

			function handleCollision(a, b, c, d) {		
	
				
				var listener = new THREE.AudioListener();
				camera.add( listener );
				var sound = new THREE.Audio( listener );
				scene.add( sound );
				var audioLoader = new THREE.AudioLoader();
				audioLoader.load( '../assets/audio/snap.mp3', function( buffer ) {
					sound.setBuffer( buffer );
					sound.setLoop( false );
					sound.setVolume( 0.5 );
					sound.play();
				});

			};

			function init() {

				document.addEventListener('mousedown', onDocumentMouseDown, false);
				document.addEventListener('mousemove', onDocumentMouseMove, false);
				document.addEventListener("keydown", onDocumentKeyDown, false);				

				scene = new Physijs.Scene;
				scene.setGravity(new THREE.Vector3(0, -2000, 0));
				scene.addEventListener( 'update', function() {
				});

				var screen_w = window.innerWidth;
				var screen_h = window.innerHeight;
				var view_angle = 45;
				var aspect = screen_w / screen_h;
				var near = 0.1;
				var far = 20000;
				camera = new THREE.PerspectiveCamera( view_angle, aspect, near, far);
				scene.add(camera);
				camera.position.set(0,150,400);
				camera.lookAt(scene.position);	

					if ( Detector.webgl )
						renderer = new THREE.WebGLRenderer( {antialias:true} );
					else
						renderer = new THREE.CanvasRenderer(); 

				renderer.setSize(screen_w, screen_h);
				container = document.getElementById( 'dominoSite' );
				container.appendChild( renderer.domElement );

				THREEx.WindowResize(renderer, camera);
				THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });

				controls = new THREE.OrbitControls( camera, renderer.domElement );

				var dominoMaterial = Physijs.createMaterial (
					new THREE.MeshLambertMaterial(new THREE.MeshLambertMaterial({
						map: new THREE.TextureLoader().load('../assets/textures/' + selMaterial + '.png'),
						side: THREE.DoubleSide,
						//color: selColor
					}),
					.5,
					.5
					 ));

				var dominoMaterialTouch = new THREE.MeshLambertMaterial({color: selColor, wireframe: true});
				var dominoGeometry = new THREE.BoxGeometry(5, 60, 25, 8, 8, 8, dominoMaterial);
				var projector = new THREE.Projector();

				var light = new THREE.HemisphereLight(0xffffbb, 0xadd8e6, 1);					
				scene.add(light);
				
				var floorTexture = new THREE.TextureLoader().load( '../assets/textures/f4.jpg' );
				floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
				floorTexture.repeat.set( 1, 1 );
				var floorMaterial = Physijs.createMaterial(new THREE.MeshPhongMaterial({map: floorTexture, side: THREE.DoubleSide}), .9, .3);
				var floorGeometry = new Physijs.BoxMesh(new THREE.BoxGeometry(500, 3, 500), floorMaterial, 0);
				var floor = new Physijs.BoxMesh(new THREE.BoxGeometry(500, 500, 3), floorMaterial, 0);
				floor.position.y = -0.5;
				floor.rotation.x = Math.PI / 2;
				scene.add(floor);

				var imagePrefix = "../assets/textures/f2.jpg";
			//	var directions  = ["1", "2", "3", "4", "5", "6"];
			//	var imageSuffix = ".jpg";
				var backgroundPic = new THREE.BoxGeometry( 5000, 5000, 5000 );
				var materialArray = [];
				
				for (var i = 0; i < 6; i++)
					materialArray.push( new THREE.MeshBasicMaterial({
						map: new THREE.TextureLoader().load(imagePrefix),
						side: THREE.DoubleSide
					}));

				//var backgroundMaterial = new THREE.Mesh( materialArray );
				var backgroundBox = new THREE.Mesh(backgroundPic, materialArray);
				scene.add(backgroundBox);

			    var floatDomino = new THREE.Mesh(dominoGeometry, dominoMaterial);
		        floatDomino.position.x = 0;
		        floatDomino.position.y = 30;
		        floatDomino.position.z = 0;
		        floatDomino.material.needsUpdate = true;		        

		        
			function onDocumentMouseDown(event) {


			    var vector = new THREE.Vector3(( event.clientX / window.innerWidth ) * 2 - 1, -( event.clientY / window.innerHeight ) * 2 + 1, 0.5);
			    vector = vector.unproject(camera);


			    var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());
			    var intersectsDomino = raycaster.intersectObject(floor);

			    if (event.button == 0 && touched == false && addDom == true) {

				    var domino = new Physijs.BoxMesh(dominoGeometry, Physijs.createMaterial(
				    	new THREE.MeshLambertMaterial({
						map: new THREE.TextureLoader().load('../assets/textures/' + selMaterial + '.png'),
						side: THREE.DoubleSide,
						//color: selColor
					}),
						.5,
						.5
					 ));

				    domino.__dirtyRotation = true;
				    domino.position.y = 3.5;
				 	domino.material.needsUpdate = true;
				    domino.position.x = intersectsDomino[0].point.x;
				    domino.position.y = intersectsDomino[0].point.y + 35;
				    domino.position.z = intersectsDomino[0].point.z;
				  	domino.rotation.y = floatDomino.rotation.y;
				  	domino._physijs.mass = 50;
				  	domino.value = 'domino';
				  	domino.addEventListener( 'collision', handleCollision );

				   	scene.add(domino);
					dominos.push(domino);
				}

				if(event.button == 2 && addDom == false) {

					for (var a=0; a<dominos.length; a++) {

						dominos[a].material.transparent = false;
						dominos[a].material.opacity = 1;

					}

					const intersectedObjects = raycaster.intersectObjects(scene.children);

					if (intersectedObjects.length) {

						pickedObject = intersectedObjects[0].object;

						if(pickedObject.value == 'domino') {

							selected = true;
						//	pickedObject.material.color.setHex(selColor);
							pickedObject.material.needsUpdate = true;
							pickedObject.material.map = new THREE.TextureLoader().load('../assets/textures/' + selMaterial + '.png');
							pickedObject.material.transparent = true;
							pickedObject.material.opacity = 0.6;

						}
						
					}

				}

			};


			function onDocumentMouseMove(event) {

				var vector = new THREE.Vector3(( event.clientX / window.innerWidth ) * 2 - 1, -( event.clientY / window.innerHeight ) * 2 + 1, 0.5);
				vector = vector.unproject(camera);

				var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());

				var intersectsFloatDomino = raycaster.intersectObject(floor);
				
				if(intersectsFloatDomino[1])

					floatDomino.position.set( intersectsFloatDomino[1].point.x , intersectsFloatDomino[1].point.y + 30, intersectsFloatDomino[1].point.z );

			//	floatDomino.material.color.setHex(selColor);
				floatDomino.material.map = new THREE.TextureLoader().load('../assets/textures/' + selMaterial + '.png');
				floatDomino.material.needsUpdate = true;
				var originPoint = floatDomino.position.clone();

				for (var vertexIndex = 0; vertexIndex < floatDomino.geometry.vertices.length; vertexIndex++) {

					var localVertex = floatDomino.geometry.vertices[vertexIndex].clone();
					var globalVertex = localVertex.applyMatrix4( floatDomino.matrix );
					var directionVector = globalVertex.sub(floatDomino.position);
					var ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize());
					var collisionResults = ray.intersectObjects(dominos);

					if (collisionResults.length > 0 && collisionResults[0].distance < directionVector.length()) {

						floatDomino.material.wireframe = true;
						touched = true;

					}

					else {

						floatDomino.material.wireframe = false;
						touched = false;

					}
				}
			};
			
			function onDocumentKeyDown(event) {


				var rotateAngle = Math.PI / 16;

				if (keyboard.pressed("a")) { 

					scene.add(floatDomino);
					addDom = true;

				}

				if (keyboard.pressed("d")) { 

					scene.remove(floatDomino);
					addDom = false;

				}

				if(keyboard.pressed("x") && addDom == false && pickedObject !== undefined) {
						
						scene.remove(pickedObject);
						dominos = dominos.filter(item => item !== pickedObject);
						pickedObject = undefined;

				}

				if(keyboard.pressed("left") && addDom == false) {

					if(pickedObject !== undefined) {

						pickedObject.rotation.x = 0.3;
						pickedObject.rotation.z = 0.3;
						pickedObject.__dirtyRotation = true;

					} else if(dominos[0] !== undefined) {

						dominos[0].rotation.x = 0.3;
						dominos[0].rotation.z = 0.3;
						dominos[0].__dirtyRotation = true;

					} else 

						return; 

				}

				if(keyboard.pressed("right") && addDom == false) {

					if(pickedObject !== undefined) {

						pickedObject.rotation.x = -0.3;
						pickedObject.rotation.z = -0.3;
						pickedObject.__dirtyRotation = true;

					} else if(dominos[0] !== undefined) {

						dominos[0].rotation.x = -0.3;
						dominos[0].rotation.z = -0.3;
						dominos[0].__dirtyRotation = true;

					} else 
					
						return; 

				}

				if(keyboard.pressed("0")) {

					location.reload();

				}

				
				if (keyboard.pressed("r") && addDom == true) {

					floatDomino.rotation.y += rotateAngle;
					floatDomino.__dirtyRotation = true;

				}

			
				if (keyboard.pressed("r") && addDom == false && pickedObject !== undefined) {

					pickedObject.rotation.y -= rotateAngle;
					pickedObject.__dirtyRotation = true;

				}

			};

		};


			function animate() {

			    requestAnimationFrame( animate );
				render();		
				update();

			};

			function update() {

				controls.update();

			};

			function render() {

				scene.simulate(undefined, 1);
				renderer.render( scene, camera );				

			};

		</script>
	</body>
</html>